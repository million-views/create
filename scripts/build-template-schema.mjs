#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, '..');

/**
 * Generate TypeScript artifacts for the template schema.
 * @param {{ rootDir?: string, check?: boolean }} options
 */
export async function buildTemplateSchema(options = {}) {
  const { rootDir = repoRoot, check = false } = options;
  const schemaDir = path.join(rootDir, 'schema');
  const typesDir = path.join(rootDir, 'types');
  const schemaFile = path.join(schemaDir, 'template.v1.json');
  const schemaLatestFile = path.join(schemaDir, 'template.json');
  const tsFile = path.join(typesDir, 'template-schema.ts');
  const dtsFile = path.join(typesDir, 'template-schema.d.ts');
  const runtimeFile = path.join(typesDir, 'template-schema.mjs');

  await assertFileExists(schemaFile, 'Template schema (template.v1.json) not found.');
  await assertFileExists(schemaLatestFile, 'Latest schema copy (template.json) not found.');

  const schemaRaw = await fs.readFile(schemaFile, 'utf8');
  const schema = JSON.parse(schemaRaw);

  basicSchemaValidation(schema);

  const version = path.basename(schemaFile, '.json');
  const tsContent = generateTypeDefinitions(schema, version, path.relative(rootDir, schemaFile));
  const runtimeContent = generateRuntimeStub(path.relative(rootDir, schemaFile));

  if (check) {
    await ensureContentMatches(tsFile, tsContent, 'template-schema.ts is out of date. Run npm run schema:build.');
    await ensureContentMatches(dtsFile, tsContent, 'template-schema.d.ts is out of date. Run npm run schema:build.');
    await ensureContentMatches(runtimeFile, runtimeContent, 'template-schema.mjs is out of date. Run npm run schema:build.');
    return;
  }

  await fs.mkdir(typesDir, { recursive: true });
  await fs.writeFile(tsFile, tsContent, 'utf8');
  await fs.writeFile(dtsFile, tsContent, 'utf8');
  await fs.writeFile(runtimeFile, runtimeContent, 'utf8');
}

async function assertFileExists(filePath, message) {
  try {
    await fs.access(filePath);
  } catch {
    throw new Error(message);
  }
}

async function ensureContentMatches(filePath, expected, message) {
  try {
    const actual = await fs.readFile(filePath, 'utf8');
    if (normalizeLineEndings(actual) !== normalizeLineEndings(expected)) {
      throw new Error(message);
    }
  } catch (error) {
    if (error.code === 'ENOENT') {
      throw new Error(message);
    }
    if (error.message === message) {
      throw error;
    }
    throw error;
  }
}

function normalizeLineEndings(value) {
  return value.replace(/\r\n/g, '\n');
}

function basicSchemaValidation(schema) {
  if (!schema || typeof schema !== 'object') {
    throw new Error('Schema must be an object.');
  }

  if (schema.type !== 'object') {
    throw new Error('Schema root type must be "object".');
  }

  if (!Array.isArray(schema.required) || !schema.required.includes('name') || !schema.required.includes('description')) {
    throw new Error('Schema must require "name" and "description" properties.');
  }

  const properties = schema.properties ?? {};
  if (!properties.setup || typeof properties.setup !== 'object') {
    throw new Error('Schema must include a setup object.');
  }

  const setupProps = properties.setup.properties ?? {};
  const authoringModeEnum = setupProps.authoringMode?.enum;
  if (!Array.isArray(authoringModeEnum) || authoringModeEnum.length === 0) {
    throw new Error('Schema setup.authoringMode must declare enum values.');
  }

  const placeholderDef = schema.$defs?.placeholder;
  if (!placeholderDef || placeholderDef.type !== 'object') {
    throw new Error('Schema must define $defs.placeholder as an object.');
  }
}

function generateTypeDefinitions(schema, version, schemaRelativePath) {
  const properties = schema.properties ?? {};
  const setup = properties.setup ?? {};
  const defs = schema.$defs ?? {};
  const authoringEnum = setup.properties?.authoringMode?.enum ?? [];
  const placeholderTypeEnum = defs.placeholder?.properties?.type?.enum ?? [];
  const dimensionTypeEnum = defs.dimension?.properties?.type?.enum ?? [];
  const policyEnum = defs.dimension?.properties?.policy?.enum ?? [];
  const canonicalVariableNames = defs.canonicalVariable?.properties?.name?.enum ?? [];

  const dimensionValueType = 'string';

  const lines = [
    '// @generated by scripts/build-template-schema.mjs',
    `// Source: ${schemaRelativePath}`,
    '',
    `export const TEMPLATE_SCHEMA_VERSION = '${version}' as const;`,
    `export const TEMPLATE_SCHEMA_PATH = '${schemaRelativePath}' as const;`,
    '',
    `export type TemplateAuthoringMode = ${enumUnion(authoringEnum)};`,
    `export type TemplatePlaceholderType = ${enumUnion(placeholderTypeEnum)};`,
    `export type TemplateDimensionType = ${enumUnion(dimensionTypeEnum)};`,
    `export type TemplateDimensionPolicy = ${enumUnion(policyEnum)};`,
  `export type TemplateCanonicalVariableName = ${enumUnion(canonicalVariableNames)};`,
    '',
    'export type TemplatePlaceholderPrimitive = string | number | boolean;',
    `export type TemplateDimensionValue = ${dimensionValueType};`,
    'export type TemplateDimensionRelation = Record<TemplateDimensionValue, TemplateDimensionValue[]>;',
    '',
    'export interface TemplatePlaceholder {',
    '  name: string;',
    '  description?: string;',
    '  required?: boolean;',
    '  sensitive?: boolean;',
    '  type?: TemplatePlaceholderType;',
    '  default?: TemplatePlaceholderPrimitive;',
    '}',
    '',
    'interface TemplateDimensionBase {',
    '  values: TemplateDimensionValue[];',
    '  requires?: TemplateDimensionRelation;',
    '  conflicts?: TemplateDimensionRelation;',
    '  policy?: TemplateDimensionPolicy;',
    '  builtIn?: boolean;',
    '  description?: string;',
    '}',
    '',
    "export interface TemplateSingleSelectDimension extends TemplateDimensionBase {",
    "  type: 'single';",
    '  default?: TemplateDimensionValue | null;',
    '}',
    '',
    "export interface TemplateMultiSelectDimension extends TemplateDimensionBase {",
    "  type: 'multi';",
    '  default?: TemplateDimensionValue[];',
    '}',
    '',
    'export type TemplateDimension = TemplateSingleSelectDimension | TemplateMultiSelectDimension;',
    'export type TemplateDimensions = Record<string, TemplateDimension>;',
    '',
  'export interface TemplateCanonicalVariableOverrides {',
  '  description?: string;',
  '  default?: TemplatePlaceholderPrimitive;',
  '  sensitive?: boolean;',
  '  type?: TemplatePlaceholderType;',
  '}',
  '',
  'export interface TemplateCanonicalVariable {',
  '  name: TemplateCanonicalVariableName;',
  '  required?: boolean;',
  '  overrides?: TemplateCanonicalVariableOverrides;',
  '}',
  '',
    'export interface TemplateMetadata {',
    '  placeholders?: TemplatePlaceholder[];',
  '  variables?: TemplateCanonicalVariable[];',
    '  [key: string]: unknown;',
    '}',
    '',
    'export interface TemplateSetup {',
    '  authoringMode?: TemplateAuthoringMode;',
    '  authorAssetsDir?: string;',
    '  dimensions?: TemplateDimensions;',
    '  supportedOptions?: TemplateDimensionValue[];',
    '}',
    '',
    'export interface TemplateManifest {',
    '  name: string;',
    '  description: string;',
    '  handoff?: string[];',
    '  metadata?: TemplateMetadata;',
    '  setup?: TemplateSetup;',
    '  [key: string]: unknown;',
    '}',
    ''
  ];

  return `${lines.join('\n')}\n`;
}

function enumUnion(values) {
  if (!Array.isArray(values) || values.length === 0) {
    return 'never';
  }
  return values.map(value => `'${value}'`).join(' | ');
}

function generateRuntimeStub(schemaRelativePath) {
  return [
    '// @generated by scripts/build-template-schema.mjs',
    `// Source: ${schemaRelativePath}`,
    '// This module intentionally exports nothing at runtime. See template-schema.d.ts for declarations.',
    'export {};',
    ''
  ].join('\n');
}

async function main() {
  const args = process.argv.slice(2);
  const check = args.includes('--check');

  try {
    await buildTemplateSchema({ check });
  } catch (error) {
    console.error(error.message);
    process.exitCode = 1;
  }
}

const invokedDirectly = process.argv[1] && pathToFileURL(process.argv[1]).href === import.meta.url;
if (invokedDirectly) {
  main();
}
