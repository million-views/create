# Templatization System Design

## Overview

The templatization system enables automatic detection and replacement of
project-specific content with reusable placeholders during template creation. It
provides a configurable, file-type-aware approach that balances automation with
author control.

## Core Principles

- **Progressive Enhancement**: Start with comprehensive defaults, allow
  customization
- **Conservative Detection**: Only transform string literals, respect manual
  work
- **Forwards Compatible**: Unknown properties/patterns are ignored, not errors
- **Template-Author Focused**: Creation-time tool, not distributed with
  templates

## Configuration File: `.templatize.json`

Generated by `make-template init`, this file defines templatization rules:

```json
{
  "version": "1.0",
  "autoDetect": true,
  "rules": {
    "package.json": [
      {
        "type": "json-value",
        "path": "$.name",
        "placeholder": "PACKAGE_NAME"
      }
    ],
    ".jsx": [
      {
        "type": "string-literal",
        "context": "jsx-text",
        "selector": "h1:first-child",
        "placeholder": "CONTENT_TITLE",
        "allowMultiple": false
      }
    ]
  }
}
```

### Top-Level Properties

- `version`: Schema version for major changes
- `autoDetect`: Enable/disable automatic templatization (default: true)
- `rules`: File-type specific pattern arrays

## Pattern Types

### JSON Files

```json
{
  "type": "json-value",
  "path": "$.name",
  "placeholder": "PACKAGE_NAME"
}
```

- Uses JSONPath syntax for value selection

### Markdown Files

```json
{
  "type": "markdown-heading",
  "level": 1,
  "placeholder": "CONTENT_TITLE",
  "allowMultiple": false
}
```

- `level`: Heading level (1-6)
- `position`: "first", "last", or omit for any

```json
{
  "type": "markdown-paragraph",
  "position": "first",
  "placeholder": "CONTENT_DESCRIPTION",
  "allowMultiple": false
}
```

### JSX Files

```json
{
  "type": "string-literal",
  "context": "jsx-text",
  "selector": "h1:first-child",
  "placeholder": "CONTENT_TITLE",
  "allowMultiple": false
}
```

- Only targets quoted string literals, not expressions
- `context`: "jsx-text" or "jsx-attribute"
- `selector`: CSS selector for element targeting
- `attribute`: Required when context is "jsx-attribute"

### HTML Files

```json
{
  "type": "html-text",
  "selector": "title",
  "placeholder": "CONTENT_TITLE",
  "allowMultiple": false
}
```

- `selector`: CSS selector for element targeting

```json
{
  "type": "html-attribute",
  "selector": "meta[name='description']",
  "attribute": "content",
  "placeholder": "CONTENT_DESCRIPTION",
  "allowMultiple": false
}
```

## Workflow Integration

### Init Command

```bash
npx make-template init --name "my-template"
# Creates template structure + .templatize.json with comprehensive defaults
```

### Convert Command

```bash
# Apply templatization rules
npx make-template convert . --yes

# Preview changes
npx make-template convert . --dry-run

# Skip auto-detect
npx make-template convert . --no-auto-detect --yes
```

### Scaffold Command

- Ignores `.templatize.json` (template-author-only tool)
- Treats it like `.template-undo.json` - meta content not distributed

## Control Mechanisms

### Skip Regions

```jsx
{
  /* @template-skip */
}
<h1>This content is never templatized</h1>;
{
  /* @end-template-skip */
}
```

### Manual Precedence

Manual placeholders take precedence over auto-detection:

```jsx
<h1>{CONTENT_TITLE}</h1>  // Manual - preserved as-is
<h2>Auto Title</h2>       // Auto-detected → {CONTENT_TITLE}
```

## Implementation Considerations

### Dependencies

**Decision: Accept external dependencies for robust AST parsing**
- **Rationale**: Templatization cannot be fully functional without proper AST handling for JSX
- **Impact**: Breaks "built only using Node.js built-ins" claim - requires README update
- **Trade-off**: Functionality and correctness outweigh dependency purity
- **Action Required**: Remove "built only using Node.js built-ins" claim from README.md

**Required Packages:**
- `tree-sitter`: Core parser engine
- `tree-sitter-javascript`: JavaScript/JSX parser
- `tree-sitter-typescript`: TypeScript/TSX parser
- `jsonpath-plus`: JSON path evaluation (lightweight)
- `jsdom`: HTML DOM parsing and CSS selector support

### Parser Requirements

- **JSX/TSX**: Tree-sitter JavaScript/TypeScript parsers for AST-based parsing
  - Distinguishes string literals from expressions (`"text"` vs `{variable}`)
  - Handles malformed code gracefully with error recovery
  - Supports incremental parsing for performance
- **HTML**: DOM parsing with CSS selector support (built-in or lightweight library)
- **JSON**: JSONPath evaluation (lightweight library)
- **Markdown**: Abstract Syntax Tree (AST) parsing (unified/remark ecosystem)

### Tree-sitter Implementation

**Parser Setup:**
```javascript
import Parser from 'tree-sitter';
import JavaScript from 'tree-sitter-javascript';
import TypeScript from 'tree-sitter-typescript';

const parser = new Parser();
parser.setLanguage(JavaScript); // .jsx files
// parser.setLanguage(TypeScript.tsx); // .tsx files
```

**Query-Based Pattern Matching:**
```javascript
// JSX text content in h1 elements
const jsxTextQuery = `
(jsx_element
  (jsx_opening_element
    name: (identifier) @tag (#eq? @tag "h1")
  )
  (jsx_text) @content
)
`;

// JSX attributes
const jsxAttrQuery = `
(jsx_attribute
  name: (identifier) @attr_name
  value: (string) @attr_value
)
`;
```

**Benefits:**
- Superior performance with incremental parsing
- Robust error recovery for malformed code
- Consistent API across languages
- Future-proof for additional language support

### Error Handling

- **Validation**: Strict on required fields, lenient on unknown properties
- **Compatibility**: Unknown pattern types logged as warnings, processing continues
- **Recovery**: Invalid patterns skipped, valid ones processed
- **Tree-sitter**: Continues parsing with partial ASTs for malformed JSX

### Performance

- **Lazy Loading**: Parsers loaded only when needed
- **Caching**: Parsed ASTs cached during single convert operation
- **Limits**: Reasonable file size limits to prevent performance issues
- **Incremental**: Tree-sitter's incremental parsing minimizes re-processing

### Content Placeholders

- `CONTENT_TITLE` - Main titles/headings
- `CONTENT_SUBTITLE` - Secondary headings
- `CONTENT_DESCRIPTION` - Descriptive text
- `CONTENT_LABEL` - Accessibility labels

### Package Placeholders

- `PACKAGE_NAME` - npm package name
- `PACKAGE_DESCRIPTION` - npm description
- `PACKAGE_AUTHOR` - Package author

### Configuration Placeholders

- `CONFIG_*` - Configuration values
- `PATH_*` - File/directory paths
- `META_*` - Metadata fields

## Version Compatibility

### Forwards Compatible

- Unknown properties in patterns → ignored
- Unknown pattern types → skipped with warning
- New top-level keys → ignored

### Backwards Compatible

- Missing optional properties → use defaults
- New pattern types → unavailable but don't break

### Migration

- Version field for major schema changes
- Optional upgrade prompts for new features
- Documentation of compatibility guarantees

## Security Considerations

- **Input Validation**: All selectors and paths validated before use
- **Sandboxing**: Template processing isolated from system operations
- **Size Limits**: Reasonable constraints on file processing
- **Path Safety**: Prevent directory traversal in file operations

## Testing Strategy

- **Unit Tests**: Individual pattern type processing
- **Tree-sitter Tests**: AST parsing accuracy, query correctness, error recovery
- **Integration Tests**: Full convert workflow with various project types
- **JSX Edge Cases**: Malformed JSX, complex expressions, nested components
- **Performance Tests**: Large file handling, incremental parsing efficiency
- **Compatibility Tests**: Old configs with new code, new configs with old code
- **Security Tests**: Malicious input handling and path traversal prevention

## Documentation Requirements

- **Pattern Reference**: Complete guide to all pattern types and options
- **Customization Guide**: How to modify `.templatize.json` for specific needs
- **Examples**: Real-world examples for common project types
- **Troubleshooting**: Common issues and solutions
- **Migration Guide**: Upgrading between versions
