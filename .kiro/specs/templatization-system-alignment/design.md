# Templatization System Alignment - Design

## Overview

This design addresses the architectural violation where the implementation deviated from the approved design specification. The goal is to align the current hardcoded implementation with the configurable `.templatize.json` system specified in the design document.

## Current State Analysis

### Implementation Reality
- **Converter**: Uses hardcoded `commonPatterns` array in `detectAndReplacePlaceholders()`
- **Processors**: Expect different pattern structures (type/context vs selector-based)
- **Config File**: Generated by `init` but never read during conversion
- **File Discovery**: Hardcoded file list in converter

### Design Specification
- **Configuration**: `.templatize.json` with `rules` object using file extensions as keys
- **Pattern Types**: Unified types (`json-value`, `markdown-heading`, `string-literal`, etc.)
- **File Processing**: Dynamic discovery based on config rules
- **Customization**: Template authors can modify patterns without code changes

## Solution Architecture

### Core Components

#### 1. Configuration Loading Integration
**File:** `bin/make-template/commands/convert/converter.js`

**Changes:**
- Import `loadConfig` from `templatize-config.mjs`
- Replace hardcoded `commonPatterns` with config loading
- Add config validation before processing
- Maintain backwards compatibility fallback

**Implementation:**
```javascript
// Load configuration
const config = loadConfig(this.options.projectPath);

// Extract patterns for each file type
const patternsByFile = this.extractPatternsFromConfig(config);
```

#### 2. Pattern Translation Layer
**File:** `bin/make-template/commands/convert/converter.js`

**Purpose:** Translate design patterns to implementation expectations

**Translation Logic:**
```javascript
function translatePattern(designPattern, fileType) {
  switch (designPattern.type) {
    case 'json-value':
      return {
        selector: designPattern.path,
        type: 'string-literal',
        context: 'json-value',
        placeholder: designPattern.placeholder,
        allowMultiple: designPattern.allowMultiple
      };

    case 'markdown-heading':
      return {
        selector: `h${designPattern.level}`,
        placeholder: designPattern.placeholder,
        allowMultiple: designPattern.allowMultiple
      };

    case 'string-literal':
      return designPattern; // Already in implementation format

    default:
      throw new Error(`Unknown pattern type: ${designPattern.type}`);
  }
}
```

#### 3. Dynamic File Discovery
**File:** `bin/make-template/commands/convert/converter.js`

**Changes:**
- Replace hardcoded `filesToProcess` array
- Generate file list from config rules
- Map file extensions to processors dynamically

**Implementation:**
```javascript
function generateFileConfigs(config) {
  const fileConfigs = [];

  for (const [filePattern, patterns] of Object.entries(config.rules)) {
    // Handle file extension patterns (.jsx, .html, etc.)
    if (filePattern.startsWith('.')) {
      const processor = this.getProcessorForExtension(filePattern);
      const commonFiles = this.getCommonFilesForExtension(filePattern);

      for (const filePath of commonFiles) {
        fileConfigs.push({
          path: filePath,
          processor,
          patterns: patterns.map(p => translatePattern(p, filePattern))
        });
      }
    }
    // Handle specific files (package.json, README.md, etc.)
    else {
      const processor = this.getProcessorForFile(filePattern);
      fileConfigs.push({
        path: filePattern,
        processor,
        patterns: patterns.map(p => translatePattern(p, filePattern))
      });
    }
  }

  return fileConfigs;
}
```

#### 4. Processor Standardization
**Files:** `lib/templatize-*.mjs`

**Goal:** Make all processors accept unified pattern format

**Approach:**
- Add pattern type detection in each processor
- Maintain backwards compatibility with existing pattern formats
- Add validation for design-compliant patterns

#### 5. Error Handling & Validation
**File:** `bin/make-template/commands/convert/converter.js`

**Enhancements:**
- Config file existence validation
- Pattern syntax validation
- Clear error messages for invalid configurations
- Graceful fallback to defaults

## Implementation Phases

### Phase 1: Configuration Integration (Foundation)
1. **Add config loading** to converter
2. **Implement pattern translation** layer
3. **Add config validation** with clear error messages
4. **Maintain hardcoded fallback** for safety

### Phase 2: Dynamic File Processing (Core Logic)
1. **Replace hardcoded file list** with dynamic generation
2. **Implement extension-to-processor mapping**
3. **Add file existence checking** from config rules
4. **Test file discovery logic**

### Phase 3: Processor Updates (Compatibility)
1. **Update markdown processor** to handle design pattern types
2. **Standardize pattern expectations** across processors
3. **Add pattern validation** in each processor
4. **Maintain backwards compatibility**

### Phase 4: Testing & Validation (Quality Assurance)
1. **Add integration tests** for config-driven conversion
2. **Test pattern translation** accuracy
3. **Validate performance** benchmarks
4. **Test error scenarios**

### Phase 5: Migration & Documentation (Completion)
1. **Update reference documentation** to match design
2. **Create migration guide** for existing usage
3. **Remove hardcoded fallback** once validated
4. **Update help text and examples**

## Data Flow

### Before (Current Implementation)
```text
Hardcoded Patterns → File List → Processor Selection → Processing
```

### After (Design Compliant)
```text
.templatize.json → Config Loading → Pattern Translation → Dynamic File Discovery → Processor Selection → Processing
```

## Error Handling Strategy

### Configuration Errors
- **Missing config file**: Use defaults with warning
- **Invalid JSON**: Clear error message with validation details
- **Invalid patterns**: Skip invalid patterns with warnings
- **Unknown pattern types**: Log warning, skip pattern

### Processing Errors
- **File not found**: Skip with debug message
- **Parser errors**: Continue with other files
- **Pattern match failures**: Continue with other patterns

## Performance Considerations

### Optimization Strategies
- **Lazy config loading**: Load once per conversion, cache in memory
- **Pattern pre-validation**: Validate patterns during config load
- **File existence caching**: Cache fs.existsSync results
- **Processor memoization**: Avoid recreating processors

### Benchmarks
- **Config loading**: < 10ms
- **Pattern translation**: < 5ms per pattern
- **File discovery**: < 20ms
- **Total overhead**: < 50ms (vs 0ms for hardcoded)

## Backwards Compatibility

### Migration Strategy
1. **Dual mode**: Support both config-driven and hardcoded modes
2. **Config priority**: Use config if available, fallback to hardcoded
3. **Deprecation warnings**: Warn when using hardcoded mode
4. **Gradual migration**: Allow time for config file adoption

### Breaking Change Management
- **Version detection**: Check for config file presence
- **Clear messaging**: Explain migration requirements
- **Helpful errors**: Guide users to create config files

## Testing Strategy

### Unit Tests
- **Pattern translation**: Test all design pattern types
- **Config loading**: Test valid/invalid configurations
- **File discovery**: Test extension-to-processor mapping

### Integration Tests
- **End-to-end conversion**: Config-driven vs hardcoded results
- **Error scenarios**: Invalid configs, missing files
- **Performance**: Benchmark config loading overhead

### Compatibility Tests
- **Existing templates**: Ensure no regression
- **Mixed scenarios**: Config + hardcoded patterns
- **Edge cases**: Malformed configs, missing processors

## Security Considerations

### Input Validation
- **Config file parsing**: Prevent JSON injection attacks
- **Pattern validation**: Sanitize selectors and paths
- **File path validation**: Prevent directory traversal
- **Processor isolation**: No arbitrary code execution

### Error Information
- **No sensitive data**: Don't leak file system information
- **Safe error messages**: Generic errors for security-sensitive failures
- **Logging levels**: Debug vs production error detail

## Success Validation

### Functional Validation
- [ ] Config file loads correctly
- [ ] Patterns translate accurately
- [ ] File discovery works dynamically
- [ ] All processors handle design patterns
- [ ] Error handling is robust

### Performance Validation
- [ ] Config loading < 50ms overhead
- [ ] No performance regression
- [ ] Memory usage remains bounded

### Compatibility Validation
- [ ] Existing templates work unchanged
- [ ] Hardcoded fallback functions
- [ ] Clear migration path provided